{"name":"Double Slice","type":"script","author":"mBLqM4dBpTch9VrM","img":"icons/weapons/daggers/dagger-twin-green.webp","scope":"global","command":"if (canvas.tokens.controlled.length !== 1) { return ui.notifications.info(\"Please select 1 token\") }\n\nif ( !token.actor.itemTypes.feat.some(f => f.slug === \"double-slice\") ) { return ui.notifications.warn(`${token.name} does not have the Double Slice feat!`) }\n\nif ( token.actor.itemTypes.weapon.filter( h => h.isMelee && h.isHeld && h.hands === \"1\" && h.handsHeld === 1 && !h.system.traits.value.includes(\"unarmed\") ).length > 2 ) { return ui.notifications.info(\"To use the double slice macro, only 2 one-handed melee weapons can be equipped at a time.\") }\n\nif ( token.actor.itemTypes.weapon.filter( h => h.isMelee && h.isHeld && h.hands === \"1\" && h.handsHeld === 1 && !h.system.traits.value.includes(\"unarmed\") ).length < 2 ) { return ui.notifications.info(\"Please equip/draw 2 one-handed melee weapons.\") }\n\nconst DamageRoll = CONFIG.Dice.rolls.find( r => r.name === \"DamageRoll\" );\nconst critRule = game.settings.get(\"pf2e\", \"critRule\");\n\nlet weapons = token.actor.system.actions.filter( h => h.item?.isMelee && h.item?.isHeld && h.item?.hands === \"1\" && h.item?.handsHeld === 1 && !h.item?.system?.traits?.value?.includes(\"unarmed\") );\n\nlet options = [\"double-slice-second\"];\nlet primary = weapons[0];\nlet secondary = weapons[1];\nif ( weapons.filter( a => a.item.system.traits.value.includes(\"agile\") ).length === 1 ) {\n    primary = weapons.find( a => !a.item.system.traits.value.includes(\"agile\") );\n    secondary = weapons.find( a => a.item.system.traits.value.includes(\"agile\") );\n}\n\nconst { map, bypass, dos } = await Dialog.wait({\n    title:\"Current MAP\",\n    content: `\n        <select id=\"map\" autofocus>\n            <option value=0>No MAP</option>\n            <option value=1>MAP 1</option>\n            <option value=2>MAP 2</option>\n        </select><hr>\n    `,\n    buttons: {\n            ok: {\n                label: \"Double Slice\",\n                icon: \"<i class='fa-solid fa-swords'></i>\",\n                callback: (html) => { return { map: parseInt(html[0].querySelector(\"#map\").value), bypass: false }  }\n            },\n            bypass: {\n                label:\"Bypass\",\n                icon: \"<i class='fa-solid fa-forward'></i>\",\n                callback: async (html) => {\n                    const map = parseInt(html[0].querySelector(\"#map\").value);\n                    const dos = await Dialog.wait({\n                        title:\"Degree of Success\",\n                        content: `\n                            <table>\n                                <tr>\n                                    <td>${primary.label} (1st)</td>\n                                    <td><select id=\"dos1\" autofocus>\n                                    <option value=2>Success</option>\n                                    <option value=3>Critical Success</option>\n                                    <option value=1>Failure</option>\n                                    <option value=0>Critical Failure</option>\n                                    </select></td></tr>\n                                <tr>\n                                    <td>${secondary.label} (2nd)</td>\n                                    <td><select id=\"dos2\">\n                                        <option value=2>Success</option>\n                                        <option value=3>Critical Success</option>\n                                        <option value=1>Failure</option>\n                                        <option value=0>Critical Failure</option>\n                                    </select></td></tr>\n                            </table><hr>\n                        `,\n                        buttons: {\n                            ok: {\n                                label: \"Reroll\",\n                                icon: \"<i class='fa-solid fa-dice'></i>\",\n                                callback: (html) => { return [parseInt(html[0].querySelector(\"#dos1\").value), parseInt(html[0].querySelector(\"#dos2\").value) ] }\n                            },\n                                                      cancel: {\n                                label: \"Cancel\",\n                                icon: \"<i class='fa-solid fa-ban'></i>\",\n                            }\n                        },\n                        default: 'ok'\n                    },{width:\"auto\"});\n                    return { map, bypass: true, dos }\n                },\n            },\n            cancel: {\n                label: \"Cancel\",\n                icon: \"<i class='fa-solid fa-ban'></i>\",\n            }\n    },\n    default: \"ok\"\n},{width:\"auto\"});\n\nif ( map === undefined ) { return; }\n\nconst cM = [];\nfunction PD(cm) {\n    if ( cm.user.id === game.userId && cm.isDamageRoll ) {\n        if ( !cM.map(f => f.flavor).includes(cm.flavor) ) {\n            cM.push(cm);\n        }\n        return false;\n    }\n}\n\nHooks.on('preCreateChatMessage', PD);\n\n\nconst pdos = bypass ? dos[0] : (await primary.variants[map].roll({skipDialog:true, event })).degreeOfSuccess;\n\nconst sdos = bypass ? dos[1] : (await secondary.variants[map].roll({skipDialog:true, event, options})).degreeOfSuccess;\n\nlet pd,sd;\nif ( pdos === 2 ) { pd = await primary.damage({event}); }\nif ( pdos === 3 ) { pd = await primary.critical({event}); }\nif ( sdos === 2 ) { sd = await secondary.damage({event}); }\nif ( sdos === 3 ) { sd = await secondary.critical({event}); }\n\nHooks.off('preCreateChatMessage', PD);\n\nif ( sdos <= 1 ) { \n    if ( pdos === 2) {\n        await primary.damage({event});\n        return;\n    }\n    if ( pdos === 3 ) {\n        await primary.critical({event});\n        return;\n    } \n}\n\nif ( pdos <= 1 ) { \n    if ( sdos === 2) {\n        await secondary.damage({event});\n        return;\n    }\n    if ( sdos === 3 ) {\n        await secondary.critical({event});\n        return;\n    } \n}\n\nawait new Promise( (resolve) => {\n    setTimeout(resolve,0);\n});\n\nif ( pdos <=0 && sdos <= 1 ) { return }\n\nelse {    \n    const terms = pd.terms[0].terms.concat(sd.terms[0].terms);\n    const type = pd.terms[0].rolls.map(t => t.type).concat(sd.terms[0].rolls.map(t => t.type));\n    const persistent = pd.terms[0].rolls.map(t => t.persistent).concat(sd.terms[0].rolls.map(t => t.persistent));\n    \n    let preCombinedDamage = [];\n    let combinedDamage = '{';\n    let i = 0;\n    for ( const t of terms ) {\n        if ( persistent[i] && !preCombinedDamage.find( p => p.persistent && p.terms.includes(t) ) ) {\n            preCombinedDamage.push({ terms: [t], type: type[i], persistent: persistent[i] });\n        }\n        if ( !preCombinedDamage.some(pre => pre.type === type[i]) && !persistent[i] ) {\n            preCombinedDamage.push({ terms: [terms[i]], type: type[i], persistent: persistent[i] });\n        }\n        else if ( !persistent[i] ) {\n            preCombinedDamage.find( pre => pre.type === type[i] ).terms.push(t);\n        }\n        i++;\n    }\n\n    const pOc = preCombinedDamage.filter( t => t.terms?.some( p => p.includes(\"[precision]\") ) ).map( t => t.terms ).flat();\n    if ( pOc.length > 1 ) {\n        if ( pOc[0] === pOc[1] && critRule === \"doubledice\" ) {\n            if ( pOc[1].includes(\"doubled\") && pOc[0].includes(\"doubled\") ) {\n                preCombinedDamage[0].terms[1] = preCombinedDamage[0].terms[1].replace(/ \\+ \\(...\\[doubled\\]\\)\\[precision\\]/, \"\" );\n            }\n            if ( pOc[0].includes(\"doubled\") && !pOc[1].includes(\"doubled\") ) {\n                preCombinedDamage[0].terms[1] = preCombinedDamage[0].terms[1].replace(/ \\+ ...\\[precision\\]/, \"\" );\n            }\n            if ( !pOc[0].includes(\"doubled\") && pOc[1].includes(\"doubled\") ) {\n                preCombinedDamage[0].terms[0] = preCombinedDamage[0].terms[0].replace(/ \\+ ...\\[precision\\]/, \"\" );\n            }\n            else {\n                preCombinedDamage[0].terms[1] = preCombinedDamage[0].terms[1].replace(/ \\+ ...\\[precision\\]/, \"\" );\n            }\n        }\n        else {\n            if ( pOc[0].includes(\"doubled\") && !pOc[1].includes(\"doubled\") ) {\n                preCombinedDamage[1].terms[0] = preCombinedDamage[1].terms[0].replace(/ \\+ ...\\[precision\\]/, \"\" );\n            }\n            else if ( !pOc[0].includes(\"doubled\") && pOc[1].includes(\"doubled\") ) {\n                preCombinedDamage[0].terms[0] = preCombinedDamage[0].terms[0].replace(/ \\+ ...\\[precision\\]/, \"\" );\n            }\n            else {\n                const doubled = pOc[0].includes(\"doubled\");\n                if ( doubled ) {\n                    pOc[0] = pOc[0].match(/\\(...\\[doubled\\]\\)\\[precision\\]\\)\\[\\w+/)[0] + \"]\" + `(Critical Success)`;\n                    pOc[1] = pOc[1].match(/\\(...\\[doubled\\]\\)\\[precision\\]\\)\\[\\w+/)[0] + \"]\" + `(Critical Success)`;\n                }\n                else if ( critRule === \"doubledamage\" && pdos === 3 && sdos === 3 ) {\n                    pOc[0] = (pOc[0].match(/...\\[precision\\]\\)\\)\\[\\w+/)[0] + \"]\").replaceAll(\")\",\"\") + `(Critical Success)`;\n                    pOc[1] = (pOc[1].match(/...\\[precision\\]\\)\\)\\[\\w+/)[0] + \"]\").replaceAll(\")\",\"\") + `(Critical Success)`;;\n                }\n                else if ( critRule === \"doubledamage\" && pdos === 3 && sdos === 2 ) {\n                    pOc[0] = (pOc[0].match(/...\\[precision\\]\\)\\)\\[\\w+/)[0] + \"]\").replaceAll(\")\",\"\") + `(Critical Success)`;\n                    pOc[1] = (pOc[1].match(/...\\[precision\\]\\)\\[\\w+/)[0] + \"]\").replaceAll(\")\",\"\") + `(Success)`;\n                }\n                else if ( critRule === \"doubledamage\" && sdos === 3 && pdos === 2 ) {\n                    pOc[0] = (pOc[0].match(/...\\[precision\\]\\)\\[\\w+/)[0] + \"]\").replaceAll(\")\",\"\") + `(Success)`;\n                    pOc[1] = (pOc[1].match(/...\\[precision\\]\\)\\)\\[\\w+/)[0] + \"]\").replaceAll(\")\",\"\") + `(Critical Success)`;; \n                }\n                else { \n                    pOc[0] = (pOc[0].match(/...\\[precision\\]\\)\\[\\w+/)[0] + \"]\").replaceAll(\")\",\"\") + `(Success)`;\n                    pOc[1] = (pOc[1].match(/...\\[precision\\]\\)\\[\\w+/)[0] + \"]\").replaceAll(\")\",\"\") + `(Success)`;\n                }\n                const pD = await Dialog.wait( {\n                    title: \"Precision Damage to Remove\",\n                    content: `\n                        <select>\n                            <option value=0>${pOc[0]}</option>\n                            <option value=1>${pOc[1]}</option>\n                        </select>\n                    `,\n                    buttons: {\n                        ok: {\n                            label: \"Remove\",\n                            icon: `<i class=\"fa-solid fa-eraser\"></i>`,\n                            callback: (html) => { \n                                return parseInt(html[0].querySelector(\"select\").value);\n                            },\n                        },\n                    },\n                    default: \"ok\",\n                },{width:\"auto\"});\n\n                if ( pD === undefined ) { return ui.notifications.warn(\"You have not selected a precision damage to remove, rerun macro in bypass, set previously rolled degrees of success, and chose damage to remove\") }\n                if ( pD === 0 && doubled ) {\n                    preCombinedDamage[0].terms[0] = preCombinedDamage[0].terms[0].replace(/ \\+ \\(...\\[doubled\\]\\)\\[precision\\]/, \"\" );\n                }\n                if ( pD === 1 && doubled ) {\n                    preCombinedDamage[1].terms[0] = preCombinedDamage[1].terms[0].replace(/ \\+ \\(...\\[doubled\\]\\)\\[precision\\]/, \"\" );\n                }\n                if ( pD === 0 && !doubled ) {\n                    preCombinedDamage[0].terms[0] = preCombinedDamage[0].terms[0].replace(/ \\+ ...\\[precision\\]/, \"\" );\n                }\n                if ( pD === 1 && !doubled ) {\n                    preCombinedDamage[1].terms[0] = preCombinedDamage[1].terms[0].replace(/ \\+ ...\\[precision\\]/, \"\" );\n                }\n            }\n        }\n    }\n\n    for ( p of preCombinedDamage ) {    \n        if ( p.persistent ) {\n        combinedDamage += `, ${p.terms.join(\",\")}`;\n        }\n        else{\n            if ( combinedDamage === \"{\" ) {\n                if ( p.terms.length > 1 ){\n                    combinedDamage += `(${p.terms.join(\" + \")})[${p.type}]`;\n                \n                }\n                else {\n                    combinedDamage += p.terms[0];\n                }\n            }\n            else if ( p.terms.length === 1 ) {\n                combinedDamage += `, ${p.terms[0]}`;\n            }\n            else {\n                combinedDamage += `, (${p.terms.join(\" + \")})[${p.type}]`;\n            }\n        }\n    }\n    \n    combinedDamage += \"}\";\n   \n    const rolls = [await new DamageRoll(combinedDamage).evaluate({ async: true })]\n    let flavor = `<strong>Double Slice Total Damage</strong>`;\n    const color = (pdos || sdos) === 2 ? `<span style=\"color:rgb(0, 0, 255)\">Success</span>` : `<span style=\"color:rgb(0, 128, 0)\">Critical Success</span>`\n    if ( cM.length === 1 ) { flavor += `<p>Same Weapon (${color})<hr>${cM[0].flavor}</p><hr>`; }\n    else { flavor += `<hr>${cM[0].flavor}<hr>${cM[1].flavor}`; }\n    if ( pdos === 3 || sdos === 3 ) {\n        flavor += `<hr><strong>TOP DAMAGE USED FOR CREATURES IMMUNE TO CRITICALS`;\n        if ( critRule === \"doubledamage\" ) {\n            rolls.unshift(await new DamageRoll(combinedDamage.replaceAll(\"2 * \", \"\")).evaluate({ async: true }));\n        }\n        else if ( critRule === \"doubledice\" ) {\n            const splitValues = combinedDamage.replaceAll(\"2 * \", \"\").replaceAll(/([\\{\\}])/g,\"\").split(\" \");\n            const toJoinVAlues = [];\n            for ( const sv of splitValues ) {\n                if ( sv.includes(\"[doubled])\") ) {\n                    const sV = sv.replaceAll(\"[doubled])\",\"\");\n                    if ( !sV.includes(\"d\") ) {\n                            toJoinVAlues.push(\"sV\");\n                            continue;\n                    }\n                    else {\n                        const n = sV.split(/(d\\d)/g);\n                        if ( n[0].charAt(1) !== \"(\") {\n                            n[0] = `${parseInt(n[0].charAt(1) / 2)}`;\n                            toJoinVAlues.push(n.join(\"\"));\n                            continue;\n                        }\n                        else if ( n[0].charAt(2) !== \"(\") { \n                            n[0] = `(${parseInt(n[0].charAt(2)) / 2}`;\n                            toJoinVAlues.push(n.join(\"\"));\n                            continue;\n                        }\n                        else { \n                            n[0] = `((${parseInt(n[0].charAt(3)) / 2}`;\n                            toJoinVAlues.push(n.join(\"\"));\n                            continue;\n                        }\n                    }\n                }\n                else {\n                toJoinVAlues.push(sv);\n                continue;\n                }\n            }\n            rolls.unshift(await new DamageRoll(`{${toJoinVAlues.join(\" \")}}`).evaluate( {async: true} ));\n        }\n    }\n    if ( cM.length === 1) {\n        options = cM[0].flags.pf2e.context.options;\n    }\n    else { options = [...new Set(cM[0].flags.pf2e.context.options.concat(cM[1].flags.pf2e.context.options))]; }\n\n    await ChatMessage.create({\n        flags: { \n            pf2e: {\n                context: {\n                    options\n                }\n            }\n        },\n        rolls,\n        type: CONST.CHAT_MESSAGE_TYPES.ROLL,\n        flavor,\n        speaker: ChatMessage.getSpeaker(),\n    });\n}","flags":{"core":{"sourceId":"Macro.NA9nNh1Tt3OUvU1I"}},"_stats":{"systemId":"pf2e","systemVersion":"4.9.1","coreVersion":"10.291","createdTime":1678704048193,"modifiedTime":1678704094082,"lastModifiedBy":"mBLqM4dBpTch9VrM"},"folder":null,"sort":0,"ownership":{"default":0,"mBLqM4dBpTch9VrM":3},"_id":"NFC44gzg52Izkf4D"}
{"name":"Flurry of Blows","type":"script","author":"mBLqM4dBpTch9VrM","img":"icons/skills/melee/unarmed-punch-fist.webp","scope":"global","command":"if ( canvas.tokens.controlled.length !== 1 ) { return ui.notifications.info(\"Please select 1 token\") }\nif ( game.user.targets.size !== 1 ) { return ui.notifications.info(\"Please select 1 target for Flurry of Blows\") }\n\nif ( !token.actor.itemTypes.action.some( f => f.slug === \"flurry-of-blows\") && !token.actor.itemTypes.feat.some(f => f.slug === \"flurry-of-blows\" ) ) { return ui.notifications.warn(`${token.name} does not have Flurry of Blows!`) }\n\nconst DamageRoll = CONFIG.Dice.rolls.find( r => r.name === \"DamageRoll\" );\nconst critRule = game.settings.get(\"pf2e\", \"critRule\");\n\nlet weapons = token.actor.system.actions.filter( h => h.visible && h.item?.isMelee && h.item?.system?.traits?.value?.includes(\"unarmed\") );\n\nif ( token.actor.system.actions.some( e => e.visible && e.origin?.type === \"effect\" && e.origin?.slug.includes(\"stance\") ) ) {\n    weapons = token.actor.system.actions.filter( e => e.visible && e.origin?.type === \"effect\" && e.origin?.slug.includes(\"stance\") ).concat(token.actor.system.actions.filter( h => h.visible && h.item?.isMelee && h.item?.system?.traits?.value?.includes(\"unarmed\") && h.origin?.type !== \"effect\" ));\n}\n\nif ( token.actor.itemTypes.feat.some( s => s.slug === \"monastic-weaponry\" ) && token.actor.system.actions.some( h => h.item?.isHeld && h.item?.system?.traits?.value.includes(\"monk\") ) ) { weapons = token.actor.system.actions.filter( h => h.item?.isHeld && h.ready && h.item?.system?.traits?.value.includes(\"monk\") ).concat(weapons) }\n\nif ( token.actor.itemTypes.effect.some( s => s.slug === \"stance-monastic-archer-stance\" ) && token.actor.system.actions.some( h => h.item?.isHeld && h.item?.group === \"bow\" && h.item?.reload === \"0\" ) ) { weapons.unshift( token.actor.system.actions.find( h => h.item?.isHeld && h.item?.group === \"bow\" && h.item?.reload === \"0\" ) ) }\n\nlet wtcf = '';\nfor ( const w of weapons ) {\n    wtcf += `<option value=${w.item.id}>${w.item.name}</option>`\n}\n\nconst { cWeapon, map, bypass, dos} = await Dialog.wait({\n    title:\"Flurry of Blows\",\n    content: `\n        <select id=\"fob1\" autofocus>\n            ${wtcf}\n        </select><br>\n        <select id=\"fob2\">\n            ${wtcf}\n        </select><hr>\n            <select id=\"map\">\n            <option value=0>No MAP</option>\n            <option value=1>MAP 1</option>\n            <option value=2>MAP 2</option>\n        </select><hr>\n    `,\n    buttons: {\n            ok: {\n                label: \"FoB\",\n                icon: \"<i class='fa-solid fa-hand-fist'></i>\",\n                callback: (html) => { return { cWeapon: [html[0].querySelector(\"#fob1\").value,html[0].querySelector(\"#fob2\").value], map: parseInt(html[0].querySelector(\"#map\").value), bypass: false } }\n            },\n            bypass: {\n                label:\"Bypass\",\n                icon: \"<i class='fa-solid fa-forward'></i>\",\n                callback: async (html) => {\n                    const cWeapon = [html[0].querySelector(\"#fob1\").value,html[0].querySelector(\"#fob2\").value];\n                    const map = parseInt(html[0].querySelector(\"#map\").value);\n                    const dos = await Dialog.wait({\n                        title:\"Degree of Success\",\n                        content: `\n                            <table>\n                                <tr>\n                                    <td>${weapons.find( w => w.item.id === cWeapon[0] ).label} (1st)</td>\n                                    <td><select id=\"dos1\" autofocus>\n                                    <option value=2>Success</option>\n                                    <option value=3>Critical Success</option>\n                                    <option value=1>Failure</option>\n                                    <option value=0>Critical Failure</option>\n                                    </select></td></tr>\n                                <tr>\n                                    <td>${weapons.find( w => w.item.id === cWeapon[1] ).label} (2nd)</td>\n                                    <td><select id=\"dos2\">\n                                        <option value=2>Success</option>\n                                        <option value=3>Critical Success</option>\n                                        <option value=1>Failure</option>\n                                        <option value=0>Critical Failure</option>\n                                    </select></td></tr>\n                            </table><hr>\n                        `,\n                        buttons: {\n                            ok: {\n                                label: \"Reroll\",\n                                icon: \"<i class='fa-solid fa-dice'></i>\",\n                                callback: (html) => { return [parseInt(html[0].querySelector(\"#dos1\").value), parseInt(html[0].querySelector(\"#dos2\").value) ] }\n                            },\n                            cancel: {\n                                label: \"Cancel\",\n                                icon: \"<i class='fa-solid fa-ban'></i>\",\n                            }\n                        },\n                        default: 'ok'\n                    },{width:\"auto\"});\n                    return { cWeapon, map, bypass: true, dos }\n                },\n            },\n            cancel: {\n                label: \"Cancel\",\n                icon: \"<i class='fa-solid fa-ban'></i>\",\n            }\n    },\n    default: \"ok\"\n},{width:\"auto\"});\n\nconst map2 = map === 2 ? map : map + 1;\nif ( cWeapon === undefined ) { return; }\n\nconst primary = weapons.find( w => w.item.id === cWeapon[0] );\nconst secondary = weapons.find( w => w.item.id === cWeapon[1] );\n\nlet options = token.actor.itemTypes.feat.some(s => s.slug === \"stunning-fist\") ? [\"stunning-fist\"] : [];\n\nconst cM = [];\nfunction PD(cm) {\n    if ( cm.user.id === game.userId && cm.isDamageRoll ) {\n        if ( !cM.map(f => f.flavor).includes(cm.flavor) ) {\n            cM.push(cm);\n        }\n        return false;\n    }\n}\n\nHooks.on('preCreateChatMessage', PD);\n\n\nconst pdos = bypass ? dos[0] : (await primary.variants[map].roll({skipDialog:true, event })).degreeOfSuccess;\n\nconst sdos = bypass ? dos[1] : (await secondary.variants[map2].roll({skipDialog:true, event})).degreeOfSuccess;\n\nlet pd,sd;\nif ( pdos === 2 ) { pd = await primary.damage({event,options}); }\nif ( pdos === 3 ) { pd = await primary.critical({event,options}); }\nif ( sdos === 2 ) { sd = await secondary.damage({event,options}); }\nif ( sdos === 3 ) { sd = await secondary.critical({event,options}); }\n\nHooks.off('preCreateChatMessage', PD);\n\nif ( sdos <= 1 ) { \n    if ( pdos === 2) {\n        await primary.damage({event,options});\n        return;\n    }\n    if ( pdos === 3 ) {\n        await primary.critical({event,options});\n        return;\n    } \n}\n\nif ( pdos <= 1 ) { \n    if ( sdos === 2) {\n        await secondary.damage({event,options});\n        return;\n    }\n    if ( sdos === 3 ) {\n        await secondary.critical({event,options});\n        return;\n    } \n}\n\nawait new Promise( (resolve) => {\n    setTimeout(resolve,0);\n});\n\nif ( pdos <=0 && sdos <= 1 ) { return }\n\nelse {    \n    const terms = pd.terms[0].terms.concat(sd.terms[0].terms);\n    const type = pd.terms[0].rolls.map(t => t.type).concat(sd.terms[0].rolls.map(t => t.type));\n    const persistent = pd.terms[0].rolls.map(t => t.persistent).concat(sd.terms[0].rolls.map(t => t.persistent));\n    \n    let preCombinedDamage = [];\n    let combinedDamage = '{';\n    let i = 0;\n    for ( const t of terms ) {\n        if ( persistent[i] && !preCombinedDamage.find( p => p.persistent && p.terms.includes(t) ) ) {\n            preCombinedDamage.push({ terms: [t], type: type[i], persistent: persistent[i] });\n        }\n        if ( !preCombinedDamage.some(pre => pre.type === type[i]) && !persistent[i] ) {\n            preCombinedDamage.push({ terms: [terms[i]], type: type[i], persistent: persistent[i] });\n        }\n        else if ( !persistent[i] ) {\n            preCombinedDamage.find( pre => pre.type === type[i] ).terms.push(t);\n        }\n        i++;\n    }\n    \n    for ( p of preCombinedDamage ) {    \n        if ( p.persistent ) {\n        combinedDamage += `, ${p.terms.join(\",\")}`;\n        }\n        else{\n            if ( combinedDamage === \"{\" ) {\n                if ( p.terms.length > 1 ){\n                    combinedDamage += `(${p.terms.join(\" + \")})[${p.type}]`;\n                \n                }\n                else {\n                    combinedDamage += p.terms[0];\n                }\n            }\n            else if ( p.terms.length === 1 ) {\n                combinedDamage += `, ${p.terms[0]}`;\n            }\n            else {\n                combinedDamage += `, (${p.terms.join(\" + \")})[${p.type}]`;\n            }\n        }\n    }\n    \n    combinedDamage += \"}\";\n    \n    const rolls = [await new DamageRoll(combinedDamage).evaluate({ async: true })]\n    let flavor = `<strong>Flurry of Blows Total Damage</strong>`;\n    const color = (pdos || sdos) === 2 ? `<span style=\"color:rgb(0, 0, 255)\">Success</span>` : `<span style=\"color:rgb(0, 128, 0)\">Critical Success</span>`\n    if ( cM.length === 1 ) { flavor += `<p>Same Weapon (${color})<hr>${cM[0].flavor}</p><hr>`; }\n    else { flavor += `<hr>${cM[0].flavor}<hr>${cM[1].flavor}`; }\n    if ( pdos === 3 || sdos === 3 ) {\n        flavor += `<hr><strong>TOP DAMAGE USED FOR CREATURES IMMUNE TO CRITICALS`;\n        if ( critRule === \"doubledamage\" ) {\n            rolls.unshift(await new DamageRoll(combinedDamage.replaceAll(\"2 * \", \"\")).evaluate({ async: true }));\n        }\n        else if ( critRule === \"doubledice\" ) {\n            const splitValues = combinedDamage.replaceAll(\"2 * \", \"\").replaceAll(/([\\{\\}])/g,\"\").split(\" \");\n            const toJoinVAlues = [];\n            for ( const sv of splitValues ) {\n                if ( sv.includes(\"[doubled])\") ) {\n                    const sV = sv.replaceAll(\"[doubled])\",\"\");\n                    if ( !sV.includes(\"d\") ) {\n                            toJoinVAlues.push(\"sV\");\n                            continue;\n                    }\n                    else {\n                        const n = sV.split(/(d\\d)/g);\n                        if ( n[0].charAt(1) !== \"(\") {\n                            n[0] = `${parseInt(n[0].charAt(1) / 2)}`;\n                            toJoinVAlues.push(n.join(\"\"));\n                            continue;\n                        }\n                        else if ( n[0].charAt(2) !== \"(\") { \n                            n[0] = `(${parseInt(n[0].charAt(2)) / 2}`;\n                            toJoinVAlues.push(n.join(\"\"));\n                            continue;\n                        }\n                        else { \n                            n[0] = `((${parseInt(n[0].charAt(3)) / 2}`;\n                            toJoinVAlues.push(n.join(\"\"));\n                            continue;\n                        }\n                    }\n                }\n                else {\n                toJoinVAlues.push(sv);\n                continue;\n                }\n            }\n            rolls.unshift(await new DamageRoll(`{${toJoinVAlues.join(\" \")}}`).evaluate( {async: true} ));\n        }\n    }\n    if ( cM.length === 1) {\n        options = cM[0].flags.pf2e.context.options;\n    }\n    else { options = [...new Set(cM[0].flags.pf2e.context.options.concat(cM[1].flags.pf2e.context.options))]; }\n\n    await ChatMessage.create({\n        flags: { \n            pf2e: {\n                context: {\n                    options\n                }\n            }\n        },\n        rolls,\n        type: CONST.CHAT_MESSAGE_TYPES.ROLL,\n        flavor,\n        speaker: ChatMessage.getSpeaker(),\n    });\n}","flags":{"core":{"sourceId":"Macro.fLkRk6xE1KCfp9IE"}},"_stats":{"systemId":"pf2e","systemVersion":"4.9.1","coreVersion":"10.291","createdTime":1678703236997,"modifiedTime":1678703995682,"lastModifiedBy":"mBLqM4dBpTch9VrM"},"folder":null,"sort":0,"ownership":{"default":0,"mBLqM4dBpTch9VrM":3},"_id":"QlhAX6coJSHgiFxf"}
{"name":"Twin Takedown","type":"script","author":"mBLqM4dBpTch9VrM","img":"icons/skills/melee/weapons-crossed-swords-yellow.webp","scope":"global","command":"if (canvas.tokens.controlled.length !== 1) { return ui.notifications.info(\"Please select 1 token\") }\n\nif ( !token.actor.itemTypes.feat.some(f => f.slug === \"twin-takedown\") ) { return ui.notifications.warn(`${token.name} does not have the Twin Takedown feat!`) }\n\nif ( token.actor.itemTypes.weapon.filter( h => h.isMelee && h.isHeld && h.hands === \"1\" && h.handsHeld === 1 && !h.system.traits.value.includes(\"unarmed\") ).length > 2 ) { return ui.notifications.info(\"To use the twin takedown macro, only 2 one-handed melee weapons can be equipped at a time.\") }\n\nif ( token.actor.itemTypes.weapon.filter( h => h.isMelee && h.isHeld && h.hands === \"1\" && h.handsHeld === 1 && !h.system.traits.value.includes(\"unarmed\") ).length < 2 ) { return ui.notifications.info(\"Please equip/draw 2 one-handed melee weapons.\") }\n\nconst DamageRoll = CONFIG.Dice.rolls.find( r => r.name === \"DamageRoll\" );\nconst critRule = game.settings.get(\"pf2e\", \"critRule\");\n\nlet weapons = token.actor.system.actions.filter( h => h.item?.isMelee && h.item?.isHeld && h.item?.hands === \"1\" && h.item?.handsHeld === 1 && !h.item?.system?.traits?.value?.includes(\"unarmed\") );\n\nlet primary = weapons[0];\nlet secondary = weapons[1];\nif ( weapons.filter( a => a.item.system.traits.value.includes(\"agile\") ).length === 1 ) {\n    primary = weapons.find( a => !a.item.system.traits.value.includes(\"agile\") );\n    secondary = weapons.find( a => a.item.system.traits.value.includes(\"agile\") );\n}\n\nconst { map, bypass, dos } = await Dialog.wait({\n    title:\"Current MAP\",\n    content: `\n        <select id=\"map\" autofocus>\n            <option value=0>No MAP</option>\n            <option value=1>MAP 1</option>\n            <option value=2>MAP 2</option>\n        </select><hr>\n    `,\n    buttons: {\n            ok: {\n                label: \"Twin Takedown\",\n                icon: \"<i class='fa-solid fa-swords'></i>\",\n                callback: (html) => { return { map: parseInt(html[0].querySelector(\"#map\").value), bypass: false }  }\n            },\n            bypass: {\n                label:\"Bypass\",\n                icon: \"<i class='fa-solid fa-forward'></i>\",\n                callback: async (html) => {\n                    const map = parseInt(html[0].querySelector(\"#map\").value);\n                    const dos = await Dialog.wait({\n                        title:\"Degree of Success\",\n                        content: `\n                            <table>\n                                <tr>\n                                    <td>${primary.label} (1st)</td>\n                                    <td><select id=\"dos1\" autofocus>\n                                    <option value=2>Success</option>\n                                    <option value=3>Critical Success</option>\n                                    <option value=1>Failure</option>\n                                    <option value=0>Critical Failure</option>\n                                    </select></td></tr>\n                                <tr>\n                                    <td>${secondary.label} (2nd)</td>\n                                    <td><select id=\"dos2\">\n                                        <option value=2>Success</option>\n                                        <option value=3>Critical Success</option>\n                                        <option value=1>Failure</option>\n                                        <option value=0>Critical Failure</option>\n                                    </select></td></tr>\n                            </table><hr>\n                        `,\n                        buttons: {\n                            ok: {\n                                label: \"Reroll\",\n                                icon: \"<i class='fa-solid fa-dice'></i>\",\n                                callback: (html) => { return [parseInt(html[0].querySelector(\"#dos1\").value), parseInt(html[0].querySelector(\"#dos2\").value) ] }\n                            },\n                                                      cancel: {\n                                label: \"Cancel\",\n                                icon: \"<i class='fa-solid fa-ban'></i>\",\n                            }\n                        },\n                        default: 'ok'\n                    },{width:\"auto\"});\n                    return { map, bypass: true, dos }\n                },\n            },\n            cancel: {\n                label: \"Cancel\",\n                icon: \"<i class='fa-solid fa-ban'></i>\",\n            }\n    },\n    default: \"ok\"\n},{width:\"auto\"});\n\nif ( map === undefined ) { return; }\nconst map2 = map === 3 ? map : map + 1;\n\nconst cM = [];\nfunction PD(cm) {\n    if ( cm.user.id === game.userId && cm.isDamageRoll ) {\n        if ( !cM.map(f => f.flavor).includes(cm.flavor) ) {\n            cM.push(cm);\n        }\n        return false;\n    }\n}\n\nHooks.on('preCreateChatMessage', PD);\n\n\nconst pdos = bypass ? dos[0] : (await primary.variants[map].roll({skipDialog:true, event })).degreeOfSuccess;\n\nconst sdos = bypass ? dos[1] : (await secondary.variants[map2].roll({skipDialog:true, event })).degreeOfSuccess;\n\nlet pd,sd;\nif ( pdos === 2 ) { pd = await primary.damage({event}); }\nif ( pdos === 3 ) { pd = await primary.critical({event}); }\nif ( sdos === 2 ) { sd = await secondary.damage({event}); }\nif ( sdos === 3 ) { sd = await secondary.critical({event}); }\n\nHooks.off('preCreateChatMessage', PD);\n\nif ( sdos <= 1 ) { \n    if ( pdos === 2) {\n        await primary.damage({event});\n        return;\n    }\n    if ( pdos === 3 ) {\n        await primary.critical({event});\n        return;\n    } \n}\n\nif ( pdos <= 1 ) { \n    if ( sdos === 2) {\n        await secondary.damage({event});\n        return;\n    }\n    if ( sdos === 3 ) {\n        await secondary.critical({event});\n        return;\n    } \n}\n\nawait new Promise( (resolve) => {\n    setTimeout(resolve,0);\n});\n\nif ( pdos <=0 && sdos <= 1 ) { return }\n\nelse {    \n    const terms = pd.terms[0].terms.concat(sd.terms[0].terms);\n    const type = pd.terms[0].rolls.map(t => t.type).concat(sd.terms[0].rolls.map(t => t.type));\n    const persistent = pd.terms[0].rolls.map(t => t.persistent).concat(sd.terms[0].rolls.map(t => t.persistent));\n    \n    let preCombinedDamage = [];\n    let combinedDamage = '{';\n    let i = 0;\n    for ( const t of terms ) {\n        if ( persistent[i] && !preCombinedDamage.find( p => p.persistent && p.terms.includes(t) ) ) {\n            preCombinedDamage.push({ terms: [t], type: type[i], persistent: persistent[i] });\n        }\n        if ( !preCombinedDamage.some(pre => pre.type === type[i]) && !persistent[i] ) {\n            preCombinedDamage.push({ terms: [terms[i]], type: type[i], persistent: persistent[i] });\n        }\n        else if ( !persistent[i] ) {\n            preCombinedDamage.find( pre => pre.type === type[i] ).terms.push(t);\n        }\n        i++;\n    }\n\n    for ( p of preCombinedDamage ) {    \n        if ( p.persistent ) {\n        combinedDamage += `, ${p.terms.join(\",\")}`;\n        }\n        else{\n            if ( combinedDamage === \"{\" ) {\n                if ( p.terms.length > 1 ){\n                    combinedDamage += `(${p.terms.join(\" + \")})[${p.type}]`;\n                \n                }\n                else {\n                    combinedDamage += p.terms[0];\n                }\n            }\n            else if ( p.terms.length === 1 ) {\n                combinedDamage += `, ${p.terms[0]}`;\n            }\n            else {\n                combinedDamage += `, (${p.terms.join(\" + \")})[${p.type}]`;\n            }\n        }\n    }\n    \n    combinedDamage += \"}\";\n   \n    const rolls = [await new DamageRoll(combinedDamage).evaluate({ async: true })]\n    let flavor = `<strong>Twin Takedown Total Damage</strong>`;\n    const color = (pdos || sdos) === 2 ? `<span style=\"color:rgb(0, 0, 255)\">Success</span>` : `<span style=\"color:rgb(0, 128, 0)\">Critical Success</span>`\n    if ( cM.length === 1 ) { flavor += `<p>Same Weapon (${color})<hr>${cM[0].flavor}</p><hr>`; }\n    else { flavor += `<hr>${cM[0].flavor}<hr>${cM[1].flavor}`; }\n    if ( pdos === 3 || sdos === 3 ) {\n        flavor += `<hr><strong>TOP DAMAGE USED FOR CREATURES IMMUNE TO CRITICALS`;\n        if ( critRule === \"doubledamage\" ) {\n            rolls.unshift(await new DamageRoll(combinedDamage.replaceAll(\"2 * \", \"\")).evaluate({ async: true }));\n        }\n        else if ( critRule === \"doubledice\" ) {\n            const splitValues = combinedDamage.replaceAll(\"2 * \", \"\").replaceAll(/([\\{\\}])/g,\"\").split(\" \");\n            const toJoinVAlues = [];\n            for ( const sv of splitValues ) {\n                if ( sv.includes(\"[doubled])\") ) {\n                    const sV = sv.replaceAll(\"[doubled])\",\"\");\n                    if ( !sV.includes(\"d\") ) {\n                            toJoinVAlues.push(\"sV\");\n                            continue;\n                    }\n                    else {\n                        const n = sV.split(/(d\\d)/g);\n                        if ( n[0].charAt(1) !== \"(\") {\n                            n[0] = `${parseInt(n[0].charAt(1) / 2)}`;\n                            toJoinVAlues.push(n.join(\"\"));\n                            continue;\n                        }\n                        else if ( n[0].charAt(2) !== \"(\") { \n                            n[0] = `(${parseInt(n[0].charAt(2)) / 2}`;\n                            toJoinVAlues.push(n.join(\"\"));\n                            continue;\n                        }\n                        else { \n                            n[0] = `((${parseInt(n[0].charAt(3)) / 2}`;\n                            toJoinVAlues.push(n.join(\"\"));\n                            continue;\n                        }\n                    }\n                }\n                else {\n                toJoinVAlues.push(sv);\n                continue;\n                }\n            }\n            rolls.unshift(await new DamageRoll(`{${toJoinVAlues.join(\" \")}}`).evaluate( {async: true} ));\n        }\n    }\n    if ( cM.length === 1) {\n        options = cM[0].flags.pf2e.context.options;\n    }\n    else { options = [...new Set(cM[0].flags.pf2e.context.options.concat(cM[1].flags.pf2e.context.options))]; }\n\n    await ChatMessage.create({\n        flags: { \n            pf2e: {\n                context: {\n                    options\n                }\n            }\n        },\n        rolls,\n        type: CONST.CHAT_MESSAGE_TYPES.ROLL,\n        flavor,\n        speaker: ChatMessage.getSpeaker(),\n    });\n}","flags":{"core":{"sourceId":"Macro.giCzDaxIf1KtK96c"}},"_stats":{"systemId":"pf2e","systemVersion":"4.9.1","coreVersion":"10.291","createdTime":1678704121737,"modifiedTime":1678704211721,"lastModifiedBy":"mBLqM4dBpTch9VrM"},"folder":null,"sort":0,"ownership":{"default":0,"mBLqM4dBpTch9VrM":3},"_id":"vQ1Ao0j3ODBOYcDA"}
